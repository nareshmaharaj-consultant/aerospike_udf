---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by nareshmaharaj.
--- DateTime: 28/06/2021 12:22
---

---validateBeforeWrite
--- Stored on server /opt/aerospike/usr/udf/lua
---@param rec table
---@param bin1 table
---@param bin2 table
---@param value1 table
---@param value2 table
function validateBeforeWrite( rec, bin1, bin2, bin3, value1, value2, value3 )
    if ( value1 > 0 and value1 < 110 ) then
        if not aerospike:exists(rec) then
            rec["creationDate"] = os.time() * 1000
            aerospike:create(rec)
        end
        rec[bin1] = value1
        rec[bin2] = value2
        rec[bin3] = value3
        rec["updateTime"] = os.time() * 1000
        aerospike:update(rec)
    else
        error("1000: Invalid value")
    end
end

function totals(rec, unitsSold, mfgPrice, salesPrice)
    local unitsSold = tonumber( rec[unitsSold] )
    local salesPrice = tonumber( rec[salesPrice] )
    local totalSales = unitsSold * salesPrice
    rec["totalSales"] = totalSales

    local mfgPrice = rec[mfgPrice]
    local totalCost = mfgPrice * unitsSold
    rec["totalCost"] = totalCost

    local profit = totalSales - totalCost
    rec["profit"] = profit

    rec["profitMargin"] = math.floor( profit / totalSales * 100 )
    local vat = vatRate(rec["country"]) or 20

    rec["taxRates"] = vat

    local vatDue = ( profit / (100 + vat) ) * vat
    if ( vatDue < 0 ) then
        vatDue = 0
    end
    rec["taxDue"] = vatDue

    return aerospike:update(rec)
end

function vatRate(country)
    vatRates = {}
    vatRates["Canada"] = 26.5
    vatRates["France"] = 26.5
    vatRates["Germany"] = 30
    vatRates["UnitedStatesofAmerica"] = 21
    vatRates["Mexico"] = 30
    return vatRates[country]
end

-- REDUCER
local function reduce_stream(a, b)
    local out = map.merge(
            a,b,
            function( v1, v2)
                return round( v1 + v2, 2 )
            end
    )
    return out
end

-- SALES
local function aggregate_sales(out, rec)
    if out[ rec["country"] ] == nil then
        out[ rec["country"] ] = ( rec["totalSales"] or 0 )
    else
        out[ rec["country"] ] = out[ rec["country"] ]  + ( rec["totalSales"] or 0 )
    end
    return out
end

-- VAT DUE
local function aggregate_vatDue(out, rec)
    if out[ rec["country"] ] == nil then
        out[ rec["country"] ] = ( rec["taxDue"] or 0 )
    else
        out[ rec["country"] ] = out[ rec["country"] ]  + ( rec["taxDue"] or 0 )
    end
    return out
end

-- FILTERS --
local function countrySegmentProductFilterClosure(country_arg, segment_arg, product_arg)
    local function countrySegmentProductFilter(rec)
       local country_rec = rec["country"]
       local segment_rec = rec["segment"]
       local product_rec = rec["product"]

        --if (not country_arg or type(country_arg) ~= "string") then country_arg = nil end
        if (not segment_arg or type(segment_arg) ~= "string") then segment_arg = nil end
        if (not product_arg or type(product_arg) ~= "string") then product_arg = nil end

        local retVal = false

        if (country_arg and country_arg == country_rec) then
            retVal = true
        else
            return false
        end

        if segment_arg ~= nil then
            if (segment_arg and segment_arg == segment_rec) then
                retVal = true
            else
                return false
            end
        end

        if product_arg ~= nil then
            if (product_arg and product_arg == product_rec) then
                retVal = true
            else
                return false
            end
        end

        return retVal
    end
    return countrySegmentProductFilter
end

-- STREAMS FUNCTIONS FOR AGGREGATION (Non Filter) --
function calculateSales(stream)
    return stream:aggregate( map{ country = nil }, aggregate_sales ): reduce(reduce_stream)
end

function calculateVatDue(stream)
    return stream: aggregate( map{ country = nil }, aggregate_vatDue): reduce(reduce_stream)
end

-- STREAMS FUNCTIONS FOR AGGREGATION (Filter) --
function calculateVatDueFilter(stream, country, segment, product)
    return stream:filter(countrySegmentProductFilterClosure(country, segment, product))
            :aggregate( map{ country = nil }, aggregate_vatDue):reduce(reduce_stream)
end

function calculateSalesFilter(stream, country, segment, product)
    return stream:filter(countrySegmentProductFilterClosure(country, segment, product))
            :aggregate( map{ country = nil }, aggregate_sales ): reduce(reduce_stream)
end

function round(num, numDecimalPlaces)
    local mult = 10^(numDecimalPlaces or 0)
    if num >= 0 then return math.floor(num * mult + 0.5) / mult
    else return math.ceil(num * mult - 0.5) / mult end
end

function slice(rec, bin, a, b)
    local s = rec[bin]
    if type(s) == 'string' then
        local subs = s:sub(a, b)
        rec[bin] = subs
        return aerospike:update(rec)
    end
    return nil
end